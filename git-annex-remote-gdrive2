#!/usr/bin/env python3.6
# git-annex-remote-gdrive2 - python rewrite of git-annex-remote-gdrive to add direct support for Google Drive to git annex
#
# Install in PATH as git-annex-remote-gdrive2
#
# Copyright (C) 2017  Silvio Ankermann
#
# This program is free software: you can redistribute it and/or modify it under the terms of version 3 of the GNU
# General Public License as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#

from abc import ABC, abstractmethod

import os
import sys

from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from oauth2client.client import OAuth2Credentials

import AnnexRemote
from AnnexRemote import Reply

# The Google class
class GoogleRemote(AnnexRemote.ExportRemote):

    def __init__(self, annex):
        self.annex = annex
        self.exporting = dict()
        self.lastcheckpresent = None
        # Authentication
        self.gauth = GoogleAuth()
        self.gauth.settings['client_config_backend'] = 'settings'
        self.gauth.settings['client_config'] = {'client_id': '914459249505-ji3d9v92ealsmc4a63ns66uoj9t6mdf0.apps.googleusercontent.com', 'client_secret': 'ivD4Ms4eROu10sHc43ojgX05', 'auth_uri':'https://accounts.google.com/o/oauth2/auth', 'token_uri':'https://accounts.google.com/o/oauth2/token', 'revoke_uri': None, 'redirect_uri': 'urn:ietf:wg:oauth:2.0:oob'}
        
    def setup(self):
        self.gauth.LoadCredentialsFile("token.json")
        
        if self.gauth.credentials is None:
            self.gauth.CommandLineAuth()
            #self.gauth.LocalWebserverAuth()
        elif self.gauth.access_token_expired:
            self.gauth.Refresh()
        else:
            self.gauth.Authorize()
        
        self.gauth.SaveCredentialsFile("token.json")
        print("Setup complete. An auth token was stored in token.json. Now run 'git annex initremote' with your desired parameters. If you don't run it from the same folder, specify via token=path/to/token.json")

    def initremote(self):
        self.prefix = self.annex.getconfig("prefix")

        token_file = self.annex.getconfig("token") or "token.json"
        self.gauth.LoadCredentialsFile(token_file)

        if self.gauth.credentials is None:
            credentials = self.annex.getcreds("credentials")["user"]
            if credentials:
                self.gauth.credentials = OAuth2Credentials.from_json(credentials)
            #else:
            #    self.gauth.LocalWebserverAuth()
        
        try:
            if self.gauth.access_token_expired:
                self.gauth.Refresh()
            else:
                self.gauth.Authorize()
            self.drive = GoogleDrive(self.gauth)
            self.root = self.__getfolder(self.prefix)
        except:
            return Reply.InitremoteFailure("Failed to create directory on remote. Ensure that you are connected to the internet and have successfully run 'git-annex-remote-gdrive setup'.")

        self.annex.setconfig("root_id", self.root['id'])
        credentials = ''.join(self.gauth.credentials.to_json().split())
        self.annex.setcreds("credentials", credentials, "")
        
        #try:
        #    os.remove(token_file)
        #except:
        #    pass

        return Reply.InitremoteSuccess()

    def prepare(self):
        self.prefix = self.annex.getconfig("prefix")
        credentials = self.annex.getcreds("credentials")["user"]

        try:
            self.gauth.credentials = OAuth2Credentials.from_json(credentials)
            if self.gauth.access_token_expired:
                self.gauth.Refresh()
            else:
                self.gauth.Authorize()
            
            self.drive = GoogleDrive(self.gauth)
            self.root = self.__getfolder(self.prefix)
        except:
            return Reply.PrepareFailure("Failed to create directory on remote. Ensure that gdrive has been configured correctly and has permission to access your Drive.")
        if self.root['id'] != self.annex.getconfig("root_id"):
            return Reply.PrepareFailure("ID of root folder changed. Was the repo moved? Please check remote and re-run git annex enableremote")

        credentials = ''.join(self.gauth.credentials.to_json().split())
        self.annex.setcreds("credentials", credentials, "")
        return Reply.PrepareSuccess()

    def transfer_store(self, key, file_):
        if self.lastcheckpresent and self.lastcheckpresent.key == key:
            checkpresent_result = self.lastcheckpresent
        else:
            checkpresent_result = self.checkpresent(key)

        if isinstance(checkpresent_result, Reply.CheckpresentSuccess):
            return Reply.TransferSuccess_Store(key)
        elif isinstance(checkpresent_result, Reply.CheckpresentUnknown):
            return Reply.TransferFailure_Store(key)
        else:
            newfile = self.drive.CreateFile({'title': key, 'parents': [{'kind': 'drive#parentReference', 'id': self.root['id']}] })
            newfile.SetContentFile(file_)
            try:
                newfile.Upload()
            except:
                return Reply.TransferFailure_Store(key)
            else:
                #self.__storeid(key, newfile['id'])
                return Reply.TransferSuccess_Store(key)
    
    def transfer_retrieve(self, key, file_):
        try:
            newfile = self.__getfile(key)
            newfile.GetContentFile(file_)
        except:
            return Reply.TransferFailure_Retrieve(key)
        else:
            return Reply.TransferSuccess_Retrieve(key)
    
    def checkpresent(self, key):
        try:
            file_list = self.drive.ListFile({'q': f"'{self.root['id']}' in parents and title='{key}' and trashed=false"}).GetList()
        except:
            self.lastcheckpresent = Reply.CheckpresentUnknown(key)
            return self.lastcheckpresent
        else:
            if (len(file_list) == 1):
                #self.__storeid(key, file_list[0]['id'])
                self.lastcheckpresent = Reply.CheckpresentSuccess(key)
                return self.lastcheckpresent
            elif (len(file_list) == 0):
                self.lastcheckpresent = Reply.CheckpresentFailure(key)
                return self.lastcheckpresent
            else:
                raise self.AmbiguousFilenameException (f"There are two or more files named {key}")

    def remove(self, key):
        try:
            file_list = self.drive.ListFile({'q': f"'{self.root['id']}' in parents and title='{key}'"}).GetList()
            for file_ in file_list:
                file_.Delete()
        except:
            return Reply.RemoveFailure(key)
        else:
            return Reply.RemoveSuccess(key)

    # export methods
    def export(self, name):
        self.exporting = self.__getexportfile(name)

    def transferexport_store(self, key, file_):
        if self.lastcheckpresent and self.lastcheckpresent.key == key:
            checkpresent_result = self.lastcheckpresent
        else:
            checkpresent_result = self.checkpresentexport(key)

        if isinstance(checkpresent_result, Reply.CheckpresentSuccess):
            return Reply.TransferSuccess_Store(key)
        elif isinstance(checkpresent_result, Reply.CheckpresentUnknown):
            return Reply.TransferFailure_Store(key)
        else:
            newfile = self.drive.CreateFile({'title': self.exporting['filename'], 'parents': [{'kind': 'drive#parentReference', 'id': self.exporting['parent']['id']}] })
            newfile.SetContentFile(file_)
            try:
                newfile.Upload()
            except:
                return Reply.TransferFailure_Store(key)
            else:
                #self.__storeid(key, newfile['id'])
                return Reply.TransferSuccess_Store(key)

    def transferexport_retrieve(self, key, file_):
        try:
            newfile = self.__getfile(self.exporting['filename'], parent=self.exporting['parent'])
            newfile.GetContentFile(file_)
        except:
            return Reply.TransferFailure_Retrieve(key)
        else:
            return Reply.TransferSuccess_Retrieve(key)
            
    def checkpresentexport(self, key):
        try:
            file_list = self.drive.ListFile({'q': f"'{self.exporting['parent']['id']}' in parents and title='{self.exporting['filename']}' and trashed=false"}).GetList()
        except:
            self.lastcheckpresent = Reply.CheckpresentUnknown(key)
            return self.lastcheckpresent
        else:
            if (len(file_list) == 1):
                #self.__storeid(key, file_list[0]['id'])
                self.lastcheckpresent = Reply.CheckpresentSuccess(key)
                return self.lastcheckpresent
            elif (len(file_list) == 0):
                self.lastcheckpresent = Reply.CheckpresentFailure(key)
                return self.lastcheckpresent
            else:
                raise self.AmbiguousFilenameException (f"There are two or more files named {key}")

    def removeexport(self, key):
        try:
            file_list = self.drive.ListFile({'q': f"'{self.exporting['parent']['id']}' in parents and title='{self.exporting['filename']}' and mimeType!='application/vnd.google-apps.folder'"}).GetList()
            for file_ in file_list:
                file_.Delete()
        except:
            return Reply.RemoveFailure(key)
        else:
            return Reply.RemoveSuccess(key)

    def removeexportdirectory(self, directory):
        exportfile = self.__getexportfile(directory)
        try:
            file_list = self.drive.ListFile({'q': f"'{exportfile['parent']['id']}' in parents and title='{exportfile['filename']}' and mimeType='application/vnd.google-apps.folder'"}).GetList()
            for file_ in file_list:
                file_.Delete()
        except:
            return Reply.RemoveexportdirectoryFailure()
        else:
            return Reply.RemoveexportdirectorySuccess()

    def renameexport(self, key, new_name):
        newfileinfo = self.__getexportfile(new_name)
        try:
            file_ = self.__getfile(self.exporting['filename'], parent=self.exporting['parent'])
            if self.exporting['path'] != newfileinfo['path']:
                file_['parents'] = [{'kind': 'drive#parentReference', 'id': newfileinfo['parent']['id']}]
            if self.exporting['filename'] != newfileinfo['filename']:
                file_['title'] = newfileinfo['filename']
            file_.Upload()
        except:
            return Reply.RenameexportFailure(key)
        else:
            return Reply.RenameexportSuccess(key)

    # internal methods
    #def __storeid(self, key, id_):
    #    self.annex.setstate(key, id_)

    def __getfile(self, filename, parent=None):
        #id_ = getstate(key)
        #if id_:
        #    return id_
        if not parent:
            parent = self.root
        file_list = self.drive.ListFile({'q': f"'{parent['id']}' in parents and title='{filename}' and trashed=false"}).GetList()
        if (len(file_list) == 1):
            return file_list[0]
        elif (len(file_list) == 0):
            return None
        else:
            raise self.AmbiguousFilenameException (f"There are two or more files named {key}")
    
    def __getfolder(self, path, root=None):
        path_list = path.split('/')
        if root:
            current_folder = root
            current_path = self.prefix
        else:
            current_folder = self.drive.CreateFile({'id': 'root'})
            current_path = ""

        for folder in path_list:
            current_path = "/".join([current_path, folder])
            file_list = self.drive.ListFile({'q': f"'{current_folder['id']}' in parents and title='{folder}' and trashed=false"}).GetList()
            if (len(file_list) == 1):
                current_folder = file_list[0]
            elif (len(file_list) == 0):
                current_folder = self.drive.CreateFile({'title': folder, 'parents': [{'kind': 'drive#parentReference', 'id': current_folder['id']}], 'mimeType': "application/vnd.google-apps.folder"})
                current_folder.Upload()
            else:
                raise self.AmbiguousFilenameException (f"There are two or more folders named {current_path}")
        return current_folder

    def __getexportfile(self, filename):
        splitpath = filename.rsplit('/',1)
        exportfile = dict()
        if len(splitpath) == 2:
            exportfile['path'] = splitpath[0]
            exportfile['filename'] = splitpath[1]
            exportfile['parent'] = self.__getfolder(exportfile['path'], root=self.root)
        else:
            exportfile['path'] = ''
            exportfile['filename'] = splitpath[0]
            exportfile['parent'] = self.root
        return exportfile


    class FileNotFoundException(Exception):
        pass
    class AmbiguousFilenameException(Exception):
        pass

def main():
    if len(sys.argv) == 2 and sys.argv[1] == "setup":
        with open(os.devnull, 'w') as devnull:
            master = RemoteMaster(devnull)
            remote = GoogleRemote(master)
            remote.setup()
        return


    # redirect all non-protocol-output to stderr
    output = sys.stdout
    sys.stdout = sys.stderr

    master = RemoteMaster(output)
    master.LinkRemote(GoogleRemote(master))
    master.Listen(sys.stdin)

if __name__ == "__main__":
    main()


