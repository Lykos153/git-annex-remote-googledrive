#!/usr/bin/env python3
# git-annex-remote-googledrive adds direct support for Google Drive to git annex using the PyDrive lib
#
# Install in PATH as git-annex-remote-googledrive
#
# Copyright (C) 2017-2018  Silvio Ankermann
#
# This program is free software: you can redistribute it and/or modify it under the terms of version 3 of the GNU
# General Public License as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#

import os, sys, traceback
import json

from drive import GoogleDrive
from drive import DriveFile
from drive import DriveFolder
from drive import NotAuthenticatedError
from keys import RemoteRoot
from keys import Key
from oauth2client.client import OAuth2Credentials
from google.auth.exceptions import RefreshError

from googleapiclient.errors import HttpError
from json.decoder import JSONDecodeError

from functools import wraps

from tenacity import Retrying, retry
from tenacity import retry_if_exception_type
from tenacity import wait_exponential, wait_fixed
from tenacity import stop_after_attempt

import annexremote
from annexremote import Master
from annexremote import ExportRemote
from annexremote import RemoteError
from annexremote import ProtocolError

def NotAFolderError(Exception):
    pass

versions = None

retry_conditions = {
        'wait': wait_exponential(multiplier=1, max=10),
        'retry': (
            retry_if_exception_type(HttpError) |
            retry_if_exception_type(ConnectionResetError)
        ),
        'stop': stop_after_attempt(5),
        'reraise': True,
    }
    
def remotemethod(f):
    @wraps(f)
    def wrapper(self, *args, **kwargs):
        try:
            return f(self, *args, **kwargs)
        except RemoteError:
            self._send_traceback()
            raise
        except:
            self._send_traceback()
            raise RemoteError

    return wrapper


class GoogleRemote(ExportRemote):

    def __init__(self, annex):
        super().__init__(annex)
        self.presence_cache = dict()
        self.state_cache = dict()
        self.chunksize = 1024**2*5

        self.gauth = json.dumps({
                        'installed':
                        {
                            'client_id': '275666578511-ndjt6mkns3vgb60cbo7csrjn6mbh8gbf.apps.googleusercontent.com',
                            'client_secret': 'Den2tu08pRU4s5KeCp5whas_',
                            'auth_uri': 'https://accounts.google.com/o/oauth2/auth',
                            'token_uri': 'https://accounts.google.com/o/oauth2/token',
                            'revoke_uri': None,
                            'redirect_uri': 'urn:ietf:wg:oauth:2.0:oob',
                        }
                    })
            

    def setup(self):
        print("======")
        print("IMPORTANT: Google has started to lockdown their Google Drive API. This might affect access to your remotes.")
        print("Until this is settled you'll see a warning about this application not being verified by Google which you need to accept in order to proceed.")
        print("Read more on https://github.com/Lykos153/git-annex-remote-googledrive#google-drive-api-lockdown")
        print("======")

        creds = GoogleDrive.auth(self.gauth)
        with open("token.json", 'w') as fp:
            fp.write(creds)
        #TODO: Store the token in the .git folder
        print("Setup complete. An auth token was stored in token.json. Now run 'git annex initremote' with your desired parameters. If you don't run it from the same folder, specify via token=path/to/token.json")
         
    def migrate(self, prefix):
        prefix = prefix
        with open("token.json", 'r') as fp:
            creds = fp.read()

        self.root = self._get_root(creds, prefix)
            
        self.migration_count = {'moved':0, 'deleted':0}
        self._migration_traverse(self.root, prefix)
        
    @retry(wait=wait_fixed(2), retry=retry_conditions['retry'])   
    def _migration_traverse(self, current_folder, current_path):
        #TODO: Use batch requests
        if current_folder == self.root:
            for subfolder in current_folder.children(files=False):
                self._migration_traverse(subfolder, current_path+"/"+subfolder.name)
        else:
            for file_ in current_folder.children():
                if isinstance(file_, DriveFolder):
                    self._migration_traverse(file_, current_path+"/"+file.name)
                else:
                    print ( "Moving {}/{}".format(current_path,file_.name) )
                    file_.move(self.root)
                    self.migration_count['moved'] += 1
            print ("Deleting folder {}".format(current_path))
            current_folder.remove()
            self.migration_count['deleted'] += 1

    def _get_root(self, creds, prefix=None, root_id=None):
        try:
            if prefix:
                return RemoteRoot.from_path(creds, prefix)
            else:
                return RemoteRoot.from_id(creds, root_id)
        except JSONDecodeError:
            raise RemoteError("Access token invalid, please re-run `git-annex-remote-googledrive setup`")
        except (NotAuthenticatedError, RefreshError):
            raise RemoteError("Failed to authenticate with Google. Please run 'git-annex-remote-googledrive setup'.")
        except FileNotFoundError:
            if prefix:
                raise RemoteError("Prefix {} does not exist or does not point to a folder.".format(prefix))
            else:
                raise RemoteError("File ID {} does not exist or does not point to a folder.".format(root_id))
        except Exception as e:
            raise RemoteError("Failed to connect with Google. Please check your internet connection.", e)


    @remotemethod
    def initremote(self):
        self._send_version()
        prefix = self.annex.getconfig('prefix')
        root_id = self.annex.getconfig('root_id')
        if not prefix and not root_id:
            raise RemoteError("Either prefix or root_id must be given.")

        token_file = self.annex.getconfig('token') or 'token.json'
        try:
            with open(token_file, 'r') as fp:
                credentials = fp.read()
        except:
            credentials = None
        if self.annex.getconfig('keep_token') != 'yes':
            try:
                os.remove(token_file)
            except FileNotFoundError:
                pass
            except Exception as e:
                self._info("Could not delete token file. {}".format(e))

        if credentials is None:
            credentials = self.annex.getcreds('credentials')['user']
            if not credentials:
                raise RemoteError("No Credentials found. Run 'git-annex-remote-googledrive setup' in order to authenticate.")

        self.root = self._get_root(credentials, prefix, root_id)

        if self.annex.getconfig('exporttree') != 'yes':
            if next(self.root.children(files=False)):
                raise RemoteError("{prefix} has subdirectories. Are you sure 'prefix' or 'id' is set correctly? In case you're migrating from gdrive or rclone, run 'git-annex-remote-googledrive migrate {prefix}' first.".format(prefix=prefix))
        

        self.annex.setconfig('root_id', self.root.id)
        credentials = ''.join(self.root.json_creds().split())
        self.annex.setcreds('credentials', credentials, '')

    @remotemethod
    def prepare(self):
        self._send_version()
        prefix = self.annex.getconfig('prefix')
        root_id = self.annex.getconfig('root_id')
        credentials = self.annex.getcreds('credentials')['user']

        if self.annex.getconfig('mute-api-lockdown-warning') != "true":
            self._info("====== git-annex-remote-googledrive")
            self._info("IMPORTANT: Google has started to lockdown their Google Drive API. This might affect access to your Google Drive remotes.")
            self._info("Please consider untrusting this remote until it is clear what happends next.")
            self._info("Read more on https://github.com/Lykos153/git-annex-remote-googledrive#google-drive-api-lockdown")
            self._info("You can mute this warning by issuing 'git annex enableremote <remote-name> mute-api-lockdown-warning=true'")
            self._info("======")

        self.root = self._get_root(credentials, prefix, root_id)
        if self.root.id != root_id:
            raise RemoteError("ID of root folder changed. Was the repo moved? Please check remote and re-run git annex enableremote")

        credentials = ''.join(self.root.json_creds().split())
        self.annex.setcreds('credentials', credentials, '')
        
        # Clean up test keys
        query = "'{root_id}' in parents and \
                 name contains 'this-is-a-test-key'".format(
                    root_id=self.root.id
                 )

        file_list = list(self.root.drive.items_by_query(query))
        if len(file_list):
            self._info("Info: Cleaning up test keys")
        for file_ in file_list:
            file_.remove()
    
    
    @remotemethod
    @retry(**retry_conditions)
    def transfer_store(self, key, fpath):
        self.root.new_key(key).upload(fpath, self.chunksize, self._progress)

    @remotemethod
    @retry(**retry_conditions)
    def transfer_retrieve(self, key, fpath):
        self.root.get_key(key).download(fpath, chunksize=self.chunksize, progress_handler=self._progress)
    
    @remotemethod
    @retry(**retry_conditions)
    def checkpresent(self, key):
        try:
            file_ = self.root.get_key(key)
            return True
        except FileNotFoundError:
            return False

    @remotemethod
    @retry(**retry_conditions)
    def remove(self, key):
        file_ = self.root.delete_key(key)

    @remotemethod
    @retry(**retry_conditions)
    def transferexport_store(self, key, fpath, name):
        if name not in self.presence_cache:
            self.checkpresentexport(key, name)
        if not self.presence_cache[name]:
            fileinfo = self._splitpath(name)
            if fileinfo['path']:
                parent = self.root.create_path(fileinfo['path'])
            else:
                parent = self.root
            newfile = parent.new_file(fileinfo['filename'])
            if os.path.getsize(fpath):
                newfile.upload(fpath, chunksize=self.chunksize, progress_handler=self._progress)
            else:
                newfile.upload_empty()
            #self._set_key_info(key, 'md5', newfile['md5Checksum'])
            self.presence_cache[name] = True

    @remotemethod
    @retry(**retry_conditions)
    def transferexport_retrieve(self, key, fpath, name):
        file_ = self.root.child_from_path(name)
        file_.download(fpath, chunksize=self.chunksize, progress_handler=self._progress)
            
    @remotemethod
    @retry(**retry_conditions)
    def checkpresentexport(self, key, name):
        try:
            file_ = self.root.child_from_path(name)
            if file_.isfolder():
                raise RemoteError("{} is a folder, not a file".format(name))
            #TODO: check md5sum 
            # Old code:
            # if file_ and file_['md5Checksum'] == self._get_key_info(key, 'md5'):
            #     self.presence_cache[name] = True
            # elif file_ and self._get_key_info(key, 'md5') == None:
            #     self.presence_cache[name] = True
            #     self._set_key_info(key, 'md5', file_['md5Checksum'])
            # elif file_ and file_['md5Checksum'] != self._get_key_info(key, 'md5'):
            #     raise RemoteError("{} was changed on remote side. Check the file or delete it in order to continue.".format(name))
            # Will RemoteError result in CHECKPRESENT-UNKNOWN or in ERROR? Which do I want?

            self.presence_cache[name] = True
        except FileNotFoundError:
            self.presence_cache[name] = False
        return self.presence_cache[name]

    @remotemethod
    @retry(**retry_conditions)
    def removeexport(self, key, name):
        try:
            file_ = self.root.child_from_path(name)
            if file_.isfolder():
                raise RemoteError("{} is a folder. Not deleting".format(name))
            file_.remove()
        except FileNotFoundError:
            pass

    @remotemethod
    @retry(**retry_conditions)
    def removeexportdirectory(self, directory):
        try:
            file_ = self.root.child_from_path(directory)
            if not file_.isfolder():
                raise RemoteError("{} is a file. Not deleting".format(directory))
            file_.remove()
        except FileNotFoundError:
            pass

    @remotemethod
    @retry(**retry_conditions)
    def renameexport(self, key, name, new_name):
        file_ = self.root.child_from_path(name)
        newfileinfo = self._splitpath(new_name)
        if newfileinfo['path']:
            newparent = self.root.create_path(newfileinfo['path'])
        else:
            newparent = self.root
        file_.move(newparent, newfileinfo['filename'])
            
    def _progress(self, progress):
        self.annex.progress(progress.resumable_progress)

    def _splitpath(self, filename):
        splitpath = filename.rsplit('/', 1)
        exportfile = dict()
        if len(splitpath) == 2:
            exportfile['path'] = splitpath[0]
            exportfile['filename'] = splitpath[1]
        else:
            exportfile['path'] = ''
            exportfile['filename'] = splitpath[0]
        return exportfile

    def _send_traceback(self):
        self._send_version()
        for line in traceback.format_exc().splitlines():
            self.annex.debug(line)
            
    def _send_version(self):
        global get_versions
        versions = get_versions()
        self.annex.debug("Running {} version {}".format(
                            os.path.basename(__file__),
                            versions['this']
                        ))
        self.annex.debug("Using AnnexRemote version", versions['annexremote'])
    
    def _info(self, message):
        try:
            self.annex.info(message)
        except ProtocolError:
            print(message, file=sys.stderr)
    
    def _get_key_info(self, key, field):
        if key not in self.state_cache or field not in self.state_cache[key]:
            try:
                self.state_cache[key] = json.loads(self.annex.getstate(key))
            except:
                self.state_cache[key] = {field: None}
        return self.state_cache[key][field]
            
    def _set_key_info(self, key, field, value):
        if self._get_key_info(key, field) != value:
            self.state_cache[key][field] = value
            self.annex.setstate(key, 
                                json.dumps(
                                    self.state_cache[key],
                                    separators=(',', ':')
                                ))
        
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def get_versions():
    output = {}
    if versions:
        output['this'] = versions['version']
    else:
        output['this'] = "unknown"
    if hasattr(annexremote, '__version__'):
        output['annexremote'] = annexremote.__version__
    else:
        output['annexremote'] = "unknown"
    return output

def main():
    if len(sys.argv) > 1:
        if sys.argv[1] == 'setup':
            with open(os.devnull, 'w') as devnull:
                master = Master(devnull)
                remote = GoogleRemote(master)
                remote.setup()
            return
        elif sys.argv[1] == 'version':
            print(os.path.basename(__file__), get_versions()['this'])
            print("Using AnnexRemote", get_versions()['annexremote'])
            return
        elif sys.argv[1] == 'migrate':
            with open(os.devnull, 'w') as devnull:
                master = Master(devnull)
                remote = GoogleRemote(master)
                if len(sys.argv) != 3:
                    print ("Usage: git-annex-remote-googledrive migrate <prefix>")
                    return
                    
                try:
                    remote.migrate(sys.argv[2])
                except (KeyboardInterrupt, SystemExit):
                    print ("\n{}Exiting.".format(bcolors.WARNING))
                    if hasattr(remote, 'migration_count') and \
                                    remote.migration_count['moved'] != 0:
                        print ("The remote is in an undefined state now. Re-run this script before using git-annex on it.")
                except Exception as e:
                    print ("\n{}Error: {}".format(bcolors.FAIL, e))
                    if hasattr(remote, 'migration_count') and \
                                    remote.migration_count['moved'] != 0:
                        print ("The remote is in an undefined state now. Re-run this script before using git-annex on it.")
                else:
                    print ("\n{}Finished.".format(bcolors.OKGREEN))
                    print ("The remote has benn successfully migrated and can now be used with git-annex-remote-googledrive. Consider checking consistency with 'git annex fsck --from=<remotename> --fast'")
                    print ( "Processed {} subfolders".format(
                                    remote.migration_count['deleted']))
                    print ( "Moved {} files{}".format(
                                remote.migration_count['moved'],
                                bcolors.ENDC
                            )
                    )

            return

    output = sys.stdout
    sys.stdout = sys.stderr

    master = Master(output)
    master.LinkRemote(GoogleRemote(master))
    master.Listen()


if __name__ == '__main__':
    main()


			
